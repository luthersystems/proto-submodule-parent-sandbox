# Parent Proto Experiment

This repository demonstrates how to structure a parent + submodule protobuf workspace, without requiring Buf Schema Registry (BSR) pushes. This pattern is useful when:

* You want to avoid publishing proto definitions externally.
* You want to support local development across multiple proto modules.
* You need a clean separation between core APIs and submodules.

The main APIs are defined under `api/`.
Submodules live under `submodules/`.
`api/` makes use of the protos defined in `submodules`

## IMPORTANT: Build Order

1. Always build submodules first:
```bash
cd submodules/weather
make
cd ../..
```

2. Then build the parent:
```bash
make
```

## Repository structure

```
.
├── api
│   ├── srvpb
│   │   └── v1
│   │       └── worldstate.proto         # Shared message definitions
│   └── worldstatepb
│       └── v1
│           └── worldstate.proto         # Worldstate gRPC + HTTP API definitions
├── buf.gen.yaml                         # Code generation config
├── buf.lock
├── buf.yaml                             # Buf workspace + module config
├── common.config.mk
├── common.mk
├── go.mod
├── go.sum
├── Makefile                             # Makefile making use of Luther BuildEnv
├── README.md
└── submodules
    └── weather                          # Weather submodule with similar structure
        ├── api
        │   └── weatherpb
        │       └── v1
        │           └── weather.proto
        ├── buf.gen.yaml
        ├── buf.lock
        ├── buf.yaml
        ├── common.config.mk
        ├── common.mk
        ├── go.mod
        ├── go.sum
        └── Makefile
```

## Submodule Independence

Each submodule (e.g., `submodules/weather/`) is a fully valid standalone protobuf module. You can run code generation directly from within that directory:

```bash
cd submodules/weather
make
```

This validates and generates code for just the submodule.
Each submodule defines its own buf.yaml and buf.gen.yaml, allowing for independent development, validation, and code generation.

## Buf configuration

`buf.yaml` declares workspace and modules:

```yaml
version: v2

modules:
  - path: api
    name: buf.build/acme/worldstate

  - path: submodules/weather/api
    name: buf.build/acme/weather

deps:
  - buf.build/googleapis/googleapis
  - buf.build/grpc-ecosystem/grpc-gateway

lint:
  use:
    - STANDARD

breaking:
  use:
    - PACKAGE
```

Declares 2 Buf modules:
- `api/` → `worldstate`
- `submodules/weather/api/` → `weather`

These modules are generated and validated independently but share a workspace.
External deps include Google well-known types and grpc-gateway extensions.

## Path Resolution and Package Structure

### Package structure in proto files

#### `worldstate.proto` — shared message types

Located at:
`api/pb/v1/worldstate.proto`

```
package worldstatepb.v1;
option go_package = "github.com/luthersystems/proto-submodule-parent-sandbox/generated/worldstatepb/v1;v1";
```

→ Package name for protobuf = pb.v1
→ Go package = v1 (files generated to: `./generated/worldstatepb/v1/`)

#### `srvpb/worldstate.proto` — service definition

Located at:
`api/srvpb/v1/worldstate.proto`

```
package srvpb.v1;
option go_package = "github.com/luthersystems/proto-submodule-parent-sandbox/generated/srvpb/v1;v1";
import "pb/v1/worldstate.proto";
```

→ Depends on shared message types via import paths above
→ Protoc resolves this import relative to the declared inputs: in buf.gen.yaml (i.e. api/).
→ Generated output: `./generated/srvpb/v1/*.pb.go`

#### `weather.proto` — weather submodule

Located at:
`submodules/weather/api/weatherpb/v1/weather.proto`

```
package pb.v1;
option go_package = "github.com/luthersystems/proto-submodule-nested-sandbox/generated/weatherpb/v1;v1";
```

→ Similarly defines its own package weatherpb.v1 
→ Generated output: `submodules/weather/generated/weatherpb/v1/*.pb.go`

## Using the child module

Each submodule owns its own buf.yaml, buf.gen.yaml and Makefile.
Submodule code is generated by running `make` inside the submodule.

Benefits:
- Fully independent development
- Submodules can evolve independently
- Clear separation of concerns
- No need to modify parent build process when adding new submodules

1. Each submodule defines its own fully qualified option go_package using its own Go module path:

```
option go_package = "github.com/luthersystems/proto-submodule-nested-sandbox/generated/weatherpb/v1;weatherpbv1";
```

2. Clone or vendor the submodule repo into the parent's submodules/ directory:

```bash
git clone git@github.com:luthersystems/proto-submodule-nested-sandbox.git submodules/weather
cd submodules/weather
make
cd ../..
make
```

3. In `go.mod`, use a replace directive so that the parent module can find the generated go code:

```
module github.com/luthersystems/proto-submodule-sandbox

go 1.24.3

replace github.com/luthersystems/proto-submodule-nested-sandbox => ./submodules/weather

require (
	github.com/luthersystems/proto-submodule-nested-sandbox v0.0.0-00010101000000-000000000000
	...
)
```

The parent imports submodule protos via standard Buf import paths like `import "weatherpb/v1/weather.proto";` — no relative import rewrites required, but generated go code in parent module will be able to resolve the child module using `github.com/luthersystems/proto-submodule-nested-sandbox`.

## Makefile integration

See makefile for usage. 

The Makefile supports:
- Default paths (`api/pb`, `api/srvpb`, etc.)
- Optional submodule scanning (`INCLUDE_SUBMODULES`)
- Swagger validation (`SWAGGER_VALIDATION_PATH`)
- Dockerized buildenv usage

